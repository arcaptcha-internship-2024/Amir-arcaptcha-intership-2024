### How to Store JWT in the User's Browser

**1. What is JWT and Why is It Good for Authentication?**

JSON Web Tokens (JWT) is a compact, URL-safe method of representing claims between two parties: the client (user) and the server. JWTs are widely used for authentication due to their efficiency and simplicity in maintaining a stateless, distributed system. The token itself consists of three parts: the header, the payload, and the signature. The header typically defines the token type (JWT) and the hashing algorithm, the payload contains claims (such as user data or expiration time), and the signature is generated by hashing the header and payload with a secret key. This signature allows the server to verify that the token hasn't been tampered with.

JWT is good for authentication because it enables a stateless authentication system. After a user successfully logs in, the server generates a JWT and sends it to the client. The client can store the token and send it with each request to authenticate the user without needing to store sessions on the server, thus reducing server-side memory load. This makes JWT ideal for scalable applications, especially those using microservices or distributed systems.

Moreover, the self-contained nature of JWT allows the server to authenticate requests without querying a database for each request, as all necessary information (such as the user ID and roles) is stored in the token. This can lead to performance improvements in high-traffic applications. Additionally, JWT tokens are platform-independent, making them a versatile choice for various environments, whether web, mobile, or other client-server architectures.

**2. Why Storing JWT in Local Storage Is Not Secure?**

While many developers find it convenient to store JWT tokens in the browser's `localStorage`, this approach poses significant security risks, primarily due to its vulnerability to Cross-Site Scripting (XSS) attacks. XSS attacks occur when malicious scripts are injected into web pages viewed by other users. If an attacker manages to inject JavaScript into a web page, they could easily access `localStorage` and steal sensitive information, including the JWT token.

Because the token contains crucial authentication information, gaining access to it allows the attacker to impersonate the legitimate user. Once they have the token, they can perform any action that the authenticated user can, including accessing private data or making destructive requests on behalf of the user. **This makes localStorage a risky place to store sensitive data such as JWT tokens.**

Moreover, unlike cookies, `localStorage` does not come with inherent security features like the `httpOnly` flag, which prevents JavaScript access to cookies, thus minimizing the risk of XSS-related token theft. Since modern web applications often rely heavily on JavaScript and client-side rendering, the potential for XSS attacks is high, especially if proper input sanitization and security controls aren't in place. For these reasons, storing JWT tokens in `localStorage` is generally considered a poor security practice for authentication.

**3. How to Securely Store JWT in the User's Browser?**

To securely store JWT tokens in the user's browser, the recommended method is to use **HTTP-only cookies**. HTTP-only cookies cannot be accessed by JavaScript, which prevents them from being compromised in an XSS attack. Here's a breakdown of how this method works:

### **Use HTTP-only Cookies**

An HTTP-only cookie is a cookie that is only accessible by the server and cannot be read by JavaScript running in the browser. When the server issues the JWT token after a successful login, it should be stored in an HTTP-only cookie. This ensures that the token remains secure from any client-side code that may be compromised.

### **Enable Secure and SameSite Flags**

When setting cookies, ensure that the `secure` and `SameSite` flags are set. The `secure` flag ensures that the cookie is only transmitted over HTTPS, preventing it from being sent over insecure channels. The `SameSite` flag restricts cross-site requests, mitigating the risk of Cross-Site Request Forgery (CSRF) attacks. There are three possible values for the `SameSite` attribute:

- `Strict`: The cookie is sent only when the user is navigating to your site directly (e.g., clicking on a link).
- `Lax`: The cookie is sent with top-level navigations and will block the cookie from being sent with certain types of requests, like third-party content (images, forms, etc.).
- `None`: The cookie is sent with any request, but the `secure` flag must be set.

For secure authentication, `SameSite=Strict` or `SameSite=Lax` is recommended.

### **Short-Lived JWT with Refresh Tokens**

Another approach to enhance security is to make the JWT token short-lived. This way, even if the token gets compromised, it will expire quickly, limiting the time an attacker can use it. To handle token expiration without forcing users to log in repeatedly, you can implement a **refresh token** mechanism. The refresh token can also be stored in an HTTP-only cookie. The server can issue new JWTs using the refresh token without requiring the user to re-authenticate.

### **Conclusion**

By combining HTTP-only cookies with secure flags, short-lived JWTs, and refresh tokens, you can minimize the security risks associated with JWT storage and protect sensitive user data effectively.

**4. Full Example: Back-End with Fastify and Front-End with Vue 3 (Composition API)**

### **Back-End (Fastify)**

Below is an example Fastify server that issues JWT tokens and stores them in an HTTP-only cookie.

#### 1. Install Dependencies

First, install Fastify and its JWT plugin:
```bash
npm install fastify fastify-jwt fastify-cookie
```

#### 2. Fastify JWT Setup
```js
const fastify = require('fastify')();
const fastifyCookie = require('fastify-cookie');
const fastifyJwt = require('fastify-jwt');

// Register plugins
fastify.register(fastifyCookie);
fastify.register(fastifyJwt, {
  secret: 'supersecret' // Replace with a strong secret in production
});

// Login route
fastify.post('/login', async (request, reply) => {
  const { username, password } = request.body;

  // Replace this with actual user authentication logic
  if (username === 'test' && password === 'password') {
    const token = fastify.jwt.sign({ username });

    // Set token in an HTTP-only cookie
    reply.setCookie('authToken', token, {
      httpOnly: true,
      sameSite: 'Strict',
      path: '/'
    });

    return reply.send({ message: 'Logged in successfully' });
  }

  return reply.status(401).send({ error: 'Invalid credentials' });
});

// Protected route
fastify.get('/protected', async (request, reply) => {
  try {
    const token = request.cookies.authToken;
    const decoded = fastify.jwt.verify(token);

    return reply.send({ data: 'This is protected data', user: decoded });
  } catch (err) {
    return reply.status(401).send({ error: 'Unauthorized' });
  }
});

// Start server
fastify.listen(3000, () => {
  console.log('Server is running on http://localhost:3000');
});
```

In this example:
- The JWT token is issued upon successful login and stored in an HTTP-only, secure cookie.
- A protected route verifies the token by extracting it from the cookie.

### **Front-End (Vue 3 with Composition API)**

Here's how you can implement the front-end using Vue 3 with the Composition API and Pinia for state management.

#### 1. Install Axios
You'll use Axios to make HTTP requests.
```bash
npm install axios
```

#### 2. Pinia Store (for managing authentication state)
```js
import { defineStore } from 'pinia';
import axios from 'axios';

export const useAuthStore = defineStore('auth', {
  state: () => ({
    isAuthenticated: false,
  }),
  actions: {
    async login(username, password) {
      try {
        await axios.post('http://localhost:3000/login', { username, password }, {
          withCredentials: true, // Include cookies in the request
        });
        this.isAuthenticated = true;
      } catch (error) {
        console.error('Login failed:', error);
        this.isAuthenticated = false;
      }
    },

    async checkAuth() {
      try {
        const response = await axios.get('http://localhost:3000/protected', {
          withCredentials: true, // Send cookies
        });
        console.log(response.data);
        this.isAuthenticated = true;
      } catch (error) {
        console.error('Authentication check failed:', error);
        this.isAuthenticated = false;
      }
    },
  },
});
```

#### 3. Vue 3 Component (Login Form)
```vue
<template>
  <div>
    <h1>Login</h1>
    <form @submit.prevent="login">
      <input v-model="username" placeholder="Username" required />
      <input v-model="password" type="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useAuthStore } from './stores/auth';

const username = ref('');
const password = ref('');
const authStore = useAuthStore();

const login = async () => {
  await authStore.login(username.value, password.value);
};
</script>
```

In this front-end example:
- Axios sends requests to the Fastify server, and cookies (including the JWT) are automatically included with each request.
- The authentication state is managed using Pinia's store.

With these components, you have a secure JWT-based authentication system that stores tokens safely in HTTP-only cookies and ensures sensitive information remains protected.